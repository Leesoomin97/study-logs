# 1. 머리글

Instruction Tuning, RLHF, DPO를 거치며 LLM의 모델 성능은 높아졌으나, 실제 서비스 환경에서는 여전히 다음과 같은 문제가 발생했다.

- 모델 파라미터에 없는 정보는 답할 수 없음  
- 최신 정보 반영이 어려움  
- 계산, 검색, API 호출과 같은 외부 행동을 직접 수행할 수 없음  

이는 모델 성능이 아닌 **시스템 설계의 문제**로서, 이에 LLM을 단독으로 이용하는 것이 아니라 시스템의 중심 요소로서 사용하는 구조가 등장했다.  
아래에서는 LLM을 이용하는 시스템 구조인 **RAG, Tool Use, Agent 구조**를 정리해 보고자 한다.

---

# 2. LLM 단독 사용의 구조적 한계

LLM은 본질적으로 다음 분포를 근사한다.

P(y | x)

이는 입력 `x`에 조건부로 텍스트 `y`를 생성하는 것이다.

이 구조에서는 외부 데이터베이스를 직접 조회하거나 최신 문서를 반영하는 것이 불가능하며, 정확성이 요구되는 계산이나 다단계 작업 계획 및 실행 역시 어렵다.

이러한 문제는 **모델의 입력 공간 확장** 또는 **모델의 행동 공간 확장**이 필요함을 의미하며, 이로 인해 LLM을 단독으로 사용하는 것이 아니라 **시스템 구성 요소 중 하나**로 사용하게 되었다.

---

# 3. RAG의 개념

RAG(Retrieval-Augmented Generation)는 LLM이 답변을 생성하기 전에 **외부 지식을 검색해 입력에 포함시키는 방식**이다. 이는 모델 파라미터를 바꾸지 않고 조건부 정보량을 늘리는 접근이다.

일반적인 RAG 시스템은 다음 단계를 거친다.

1. 사용자 질의 인코딩  
2. 벡터 DB에서 관련 문서 검색  
3. 검색 결과를 프롬프트에 삽입  
4. LLM이 답변 생성  

이 방식은 LLM 단독 사용과 달리:

- 최신 정보 반영 가능  
- 도메인 특화 지식 주입 가능  
- 파라미터 재학습 불필요  

라는 장점을 가진다.

반면, **검색 품질과 프롬프트 설계에 성능이 크게 의존**한다는 단점도 존재한다.

---

# 4. Tool Use 개념

RAG가 *정보를 가져오는 문제*에 집중했다면, **Tool Use**는 *행동을 수행하는 문제*에 집중한다.

Tool Use란 LLM이 검색, 계산, API 호출, 데이터베이스 쿼리 등의 **외부 함수 호출을 결정**하도록 만드는 구조이다.  
즉, 모델의 출력이 텍스트뿐 아니라 **행동(Action)**이 되기도 한다.

일반적인 Tool Use 흐름은 다음과 같다.

1. LLM이 사용자 요청을 해석  
2. 구조화된 호출 형태 생성  
3. 시스템이 해당 호출을 실행  
4. 실행 결과를 다시 LLM 입력으로 제공  

이 과정을 **Tool Calling**이라고도 한다.  
여기서 중요한 점은 **결정(LLM)**과 **실행(시스템)**이 분리되어 있다는 것이다.

---

# 5. Agent 개념

Agent란 RAG와 Tool Use를 단발적으로 사용하는 것이 아니라, **LLM을 컨트롤러로 사용해 여러 단계를 계획·실행하는 구조**를 의미한다.

Agent는 다음 능력을 가진다.

- 목표 설정  
- 현재 상태 평가  
- 다음 행동 결정  
- 결과 반영 후 재추론  

대표적인 Agent 패턴으로는 **ReAct**가 있다.  
이는 다음 사이클이 목표 달성까지 반복되는 구조이다.

- **Reasoning**: 다음에 무엇을 할지 추론  
- **Action**: 검색 또는 도구 호출  
- **Observation**: 실행 결과 확인  

결과적으로 Agent의 핵심은 **LLM이 한 번에 답을 생성하지 않고**, 중간 결과를 보며 **계획을 수정**한다는 점이다.

---

# 6. RAG, Tool Use, Agent의 관계

| 구성 요소 | 확장 대상 | 역할 |
|----------|----------|------|
| RAG | 입력 공간 | 외부 지식 주입 |
| Tool Use | 행동 공간 | 외부 기능 실행 |
| Agent | 제어 흐름 | 다단계 계획 실행 |

이 세 가지 시스템은 서로 경쟁하는 개념이 아니라, **상이한 역할을 수행하는 구성 요소**이다.  
실무에서는 이 셋을 조합해 하나의 LLM 시스템을 구성한다.

---

# 7. 마무리

LLM 시스템을 설계할 때는 다음과 같은 문제가 대두된다.

- 검색 실패 시 fallback 전략  
- 동시 호출 오류 처리  
- Agent 루프 종료 조건  
- 응답 지연 관리  
- hallucination 억제  

결과적으로 **모델 성능이 아니라 오케스트레이션과 제어 로직**이 LLM 시스템의 품질을 좌우한다.

RAG, Tool Use, Agent는 LLM이 할 수 없는 일을 시스템으로 보완함으로써 전체 시스템의 효과를 높이며,  
이에 LLM은 단독 사용을 넘어 **시스템을 조정하는 중심 컴포넌트**의 역할을 담당하게 된다.

---

